{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Nano isn't production-ready yet, it's in an early stage of development, you can always create an issue for suggestions An application architecture pattern than a framework for Flutter utilizing a unidirectional data flow. The goal of Nano is to make it easy to separate the business logic from the presentation layer, with modular state management to allow developers to build smaller parts, that can be tested in isolation. Nano is highly focused on architectural pattern and code structure that's scalable and modular to increase code re-usability with less to no refactoring. Nano is heavily inspired by existing solutions like Redux, BLoC pattern and Flux. Internally Nano has nothing out of ordinary for state management, it's just streams on top of rxdart and some helper functions to make your life easier. Nano's unidirectional data flow diagram Store Contains the application state It has computed values as getters and helper functions Store takse a Mutation Type which act as an input for the reducer Events are emitted as Streams State can't be changed directly from outside //Accepted mutation by this store enum CounterMutation { increment , decrement , error , } class CounterState extends StateManager < int , CounterMutation > { //initial state as 0 CounterState () : super ( 0 ); } Reducer Pure function simillar to Redux Receive Mutation as input and update the state as output Same mutations will always generate same results class CounterState extends StateManager < int , CounterMutation > { CounterState () : super ( 0 ); @override void reducer ( mutation ){ switch ( mutation ) { case CounterActions . increment: updateState ( cData + 1 ); break ; case CounterActions . decrement: updateState ( cData - 1 ); break ; case CounterActions . error: updateStateWithError ( \"Invalid action\" ); break ; default : throw Exception ( \"Invalid action\" ); } } } Action Actions cause change in the state Actions contains set of mutations, which are called once the action has been completed. Actions has full aschronous support All the API calls are performed in the actions body //without any body final incrementRef = ActionRef < CounterStore , Null > ( mutations: ( _ , payload ) => [ Mutation ( payload , IncrementMutation ())], ); //with body final setRef = ActionRef < CounterParam , void > ( body: ( payload ) async { await Future . delayed ( Duration ( milliseconds: payload . seconds )); }, mutations: ( result , payload ) => [ Mutation ( payload . store , CountMutation ( payload . count ))], ); Dispatcher Dispatcher is a singleton where all the actions go through Dispatcher doesn't registers store refernces The actions provided contains mutation with reference to the store and mutation type Dispatcher manages order of Actions execution // There are multiple ways to dipatch actions depending upon the // situation but this is what will be used most of times final counter = CounterStore (); //sync await setRef ( CounterParam ( counter , 5 , 200 )). run (); //async setRef ( CounterParam ( counter , 5 , 200 )). run ();","title":"Introduction"},{"location":"#introduction","text":"Nano isn't production-ready yet, it's in an early stage of development, you can always create an issue for suggestions An application architecture pattern than a framework for Flutter utilizing a unidirectional data flow. The goal of Nano is to make it easy to separate the business logic from the presentation layer, with modular state management to allow developers to build smaller parts, that can be tested in isolation. Nano is highly focused on architectural pattern and code structure that's scalable and modular to increase code re-usability with less to no refactoring. Nano is heavily inspired by existing solutions like Redux, BLoC pattern and Flux. Internally Nano has nothing out of ordinary for state management, it's just streams on top of rxdart and some helper functions to make your life easier. Nano's unidirectional data flow diagram Store Contains the application state It has computed values as getters and helper functions Store takse a Mutation Type which act as an input for the reducer Events are emitted as Streams State can't be changed directly from outside //Accepted mutation by this store enum CounterMutation { increment , decrement , error , } class CounterState extends StateManager < int , CounterMutation > { //initial state as 0 CounterState () : super ( 0 ); } Reducer Pure function simillar to Redux Receive Mutation as input and update the state as output Same mutations will always generate same results class CounterState extends StateManager < int , CounterMutation > { CounterState () : super ( 0 ); @override void reducer ( mutation ){ switch ( mutation ) { case CounterActions . increment: updateState ( cData + 1 ); break ; case CounterActions . decrement: updateState ( cData - 1 ); break ; case CounterActions . error: updateStateWithError ( \"Invalid action\" ); break ; default : throw Exception ( \"Invalid action\" ); } } } Action Actions cause change in the state Actions contains set of mutations, which are called once the action has been completed. Actions has full aschronous support All the API calls are performed in the actions body //without any body final incrementRef = ActionRef < CounterStore , Null > ( mutations: ( _ , payload ) => [ Mutation ( payload , IncrementMutation ())], ); //with body final setRef = ActionRef < CounterParam , void > ( body: ( payload ) async { await Future . delayed ( Duration ( milliseconds: payload . seconds )); }, mutations: ( result , payload ) => [ Mutation ( payload . store , CountMutation ( payload . count ))], ); Dispatcher Dispatcher is a singleton where all the actions go through Dispatcher doesn't registers store refernces The actions provided contains mutation with reference to the store and mutation type Dispatcher manages order of Actions execution // There are multiple ways to dipatch actions depending upon the // situation but this is what will be used most of times final counter = CounterStore (); //sync await setRef ( CounterParam ( counter , 5 , 200 )). run (); //async setRef ( CounterParam ( counter , 5 , 200 )). run ();","title":"Introduction"},{"location":"quickstart/","text":"Quickstart \u00b6 Here we will try to create a simple Counter app. I will be writing more tutorial about some large which will help you understand the goal of this library a lot better. Creating a store \u00b6 We need to create a Store to keep our counts track and to update the listeners automatically on every change. To create a store we need to extend our class with Store provided from the nano package class CounterStore extends Store < int , CounterMutations > { CounterStore () : super ( 0 ); } What is int and CounterMutations? The first type of the Store is the type of our state that we are going to emit. Here we are going to emit integers so it's int incase of a string it will be String this will prevent you from emiting anything other than the state defined The second type of the Store is the type of mutations. Every store responds to specific mutations, if correct mutation is received it will be send to the reducer to modify the state. We are going to define CounterMutations in next step. We have now defined our store and the argument passed to super() is the inital state. If we don't pass any argument the inital state will not be set and all the listeners will receive a waiting state which basically means that the Store hasn't emitted any events yet. Define Mutations \u00b6 Mutations are specific event which our store recognizes and responds to it. Here I'm defining class based mutations, it isn't necessary to use class based mutations simple can enums can also be use but when we want some inputs with our mutations it's better to use class based mutations as you can take the benefit of linting with static typing. abstract class CounterMutations {} class IncrementMutation extends CounterMutations {} class DecrementMutation extends CounterMutations {} class ErrorMutation extends CounterMutations {} class CountMutation extends CounterMutations { final int count ; CountMutation ( this . count ); } Now I can't send any mutations other than IncrementMutation , DecrementMutation , ErrorMutation and CountMutation . Defining Reducer \u00b6 In nano every store has it's own reducer. Reducer sole job is to respond to the mutations received. Now we will override the reducer from Store in our CounterStore class CounterStore extends Store < int , CounterMutations > { CounterStore () : super ( 0 ); @override void reducer ( mutation ) { if ( mutation is IncrementMutation ) updateState ( cData + 1 ); if ( mutation is DecrementMutation ) updateState ( cData - 1 ); if ( mutation is ErrorMutation ) updateStateWithError ( \"Invalid mutation\" ); if ( mutation is CountMutation ) updateState ( mutation . count ); } } The Store provides you two functions updateState() and updateStateWithError() which update the state and all the listners receive the latest copy of the state. When updateState is called the listeners receive a data event and the onData callback is called. When updateStateWithError is called the listeners receive an error event and the onErro callback is called. Please call updateState in reducer() only Don't create any other function or directly try to mutate the state. The way abstraction works in Dart the two functions for updating state updateState and updateStateWithError couldn't be hidden outside the class defination but please only call it in your reducer. Defining Actions \u00b6 Mutations can't be send directly to the store they are sent through Actions but since Actions also plays a major role like making async calls and once Action can cause mutation to multiple stores, when we say Actions causes change we don't strictly imply that. Actions carry the mutations and actions are added to the Dispatcher. The dispatcher waits for the Actions to complete and then it sends to the mutation to the respective stores. We will create action references and whenever we need to create an action we will call the refernce. References can be global as they are immutable but it's better you create them as static members inside a class First we will create a file actions.dart in our lib folder. Then paste the following code in the file //Actions final incrementRef = ActionRef < CounterStore , Null > ( mutations: ( _ , payload ) => [ Mutation ( payload , IncrementMutation ())], ); final decrementRef = ActionRef < CounterStore , Null > ( mutations: ( _ , payload ) => [ Mutation ( payload , DecrementMutation ())], ); final errortRef = ActionRef < CounterStore , Null > ( mutations: ( _ , payload ) => [ Mutation ( payload , ErrorMutation ())], ); final setRef = ActionRef < CounterParam , void > ( body: ( payload ) async { await Future . delayed ( Duration ( milliseconds: payload . seconds )); }, mutations: ( result , payload ) => [ Mutation ( payload . store , CountMutation ( payload . count ))], ); ActionRef has few important parameters body Optional parameter Perform all async operations here like API calls fetching from data base returns a List<Mutation(store,type)> mutations Required paramter Takes 2 paramter result the returned value of body() and payload for dependcy injection Creating our widget \u00b6 class CounterApp extends StatefulWidget { CounterApp ({ Key key }) : super ( key: key ); @override _CounterAppState createState () => _CounterAppState (); } class _CounterAppState extends State < CounterApp > { final _counter = CounterState (); void handleIncrement () => incrementRef ( _counter ). run (); void handleDecrement () => decrementRef ( _counter ). run (); void handleError () => errorRef ( _counter ). run (); void handleCount () => setRef ( CounterParam ( _counter , 5 )). run (); @override Widget build ( BuildContext context ) { return Scaffold ( appBar: AppBar ( title: Text ( \"Counter\" )), body: StateBuilder < int > ( initialState: _counter . state , stream: _counter . stream , rebuildOnly: ( state ) => (( state . data ?? 1 ) % 2 == 0 ), builder: ( context , state , init ) => Center ( child: Text ( state . toString ())), ), floatingActionButton: Column ( mainAxisAlignment: MainAxisAlignment . end , children: < Widget > [ FloatingActionButton ( mini: true , heroTag: null , onPressed: handleIncrement , child: Icon ( Icons . add ), ), FloatingActionButton ( mini: true , heroTag: null , onPressed: handleDecrement , child: Icon ( Icons . remove ), ), FloatingActionButton ( mini: true , heroTag: null , onPressed: handleError , child: Icon ( Icons . close ), ), FloatingActionButton ( mini: true , heroTag: null , onPressed: handleCount , child: Icon ( Icons . plus_one ), ), ], ), ); } } The StateBuilder widget takes the Store and listens for event. It might look very raw as because the depency inject is very loosely coupled so anyone can use their favourite depency injection library. Creating views \u00b6 Views are the integrating point this is where we build our widget tree and integrate everything. Create a file name views.dart and paste the following code. class App extends StatelessWidget { const App ({ Key key }) : super ( key: key ); @override Widget build ( BuildContext context ) { return MaterialApp ( home: CounterApp ()); } }","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"Here we will try to create a simple Counter app. I will be writing more tutorial about some large which will help you understand the goal of this library a lot better.","title":"Quickstart"},{"location":"quickstart/#creating-a-store","text":"We need to create a Store to keep our counts track and to update the listeners automatically on every change. To create a store we need to extend our class with Store provided from the nano package class CounterStore extends Store < int , CounterMutations > { CounterStore () : super ( 0 ); } What is int and CounterMutations? The first type of the Store is the type of our state that we are going to emit. Here we are going to emit integers so it's int incase of a string it will be String this will prevent you from emiting anything other than the state defined The second type of the Store is the type of mutations. Every store responds to specific mutations, if correct mutation is received it will be send to the reducer to modify the state. We are going to define CounterMutations in next step. We have now defined our store and the argument passed to super() is the inital state. If we don't pass any argument the inital state will not be set and all the listeners will receive a waiting state which basically means that the Store hasn't emitted any events yet.","title":"Creating a store"},{"location":"quickstart/#define-mutations","text":"Mutations are specific event which our store recognizes and responds to it. Here I'm defining class based mutations, it isn't necessary to use class based mutations simple can enums can also be use but when we want some inputs with our mutations it's better to use class based mutations as you can take the benefit of linting with static typing. abstract class CounterMutations {} class IncrementMutation extends CounterMutations {} class DecrementMutation extends CounterMutations {} class ErrorMutation extends CounterMutations {} class CountMutation extends CounterMutations { final int count ; CountMutation ( this . count ); } Now I can't send any mutations other than IncrementMutation , DecrementMutation , ErrorMutation and CountMutation .","title":"Define Mutations"},{"location":"quickstart/#defining-reducer","text":"In nano every store has it's own reducer. Reducer sole job is to respond to the mutations received. Now we will override the reducer from Store in our CounterStore class CounterStore extends Store < int , CounterMutations > { CounterStore () : super ( 0 ); @override void reducer ( mutation ) { if ( mutation is IncrementMutation ) updateState ( cData + 1 ); if ( mutation is DecrementMutation ) updateState ( cData - 1 ); if ( mutation is ErrorMutation ) updateStateWithError ( \"Invalid mutation\" ); if ( mutation is CountMutation ) updateState ( mutation . count ); } } The Store provides you two functions updateState() and updateStateWithError() which update the state and all the listners receive the latest copy of the state. When updateState is called the listeners receive a data event and the onData callback is called. When updateStateWithError is called the listeners receive an error event and the onErro callback is called. Please call updateState in reducer() only Don't create any other function or directly try to mutate the state. The way abstraction works in Dart the two functions for updating state updateState and updateStateWithError couldn't be hidden outside the class defination but please only call it in your reducer.","title":"Defining Reducer"},{"location":"quickstart/#defining-actions","text":"Mutations can't be send directly to the store they are sent through Actions but since Actions also plays a major role like making async calls and once Action can cause mutation to multiple stores, when we say Actions causes change we don't strictly imply that. Actions carry the mutations and actions are added to the Dispatcher. The dispatcher waits for the Actions to complete and then it sends to the mutation to the respective stores. We will create action references and whenever we need to create an action we will call the refernce. References can be global as they are immutable but it's better you create them as static members inside a class First we will create a file actions.dart in our lib folder. Then paste the following code in the file //Actions final incrementRef = ActionRef < CounterStore , Null > ( mutations: ( _ , payload ) => [ Mutation ( payload , IncrementMutation ())], ); final decrementRef = ActionRef < CounterStore , Null > ( mutations: ( _ , payload ) => [ Mutation ( payload , DecrementMutation ())], ); final errortRef = ActionRef < CounterStore , Null > ( mutations: ( _ , payload ) => [ Mutation ( payload , ErrorMutation ())], ); final setRef = ActionRef < CounterParam , void > ( body: ( payload ) async { await Future . delayed ( Duration ( milliseconds: payload . seconds )); }, mutations: ( result , payload ) => [ Mutation ( payload . store , CountMutation ( payload . count ))], ); ActionRef has few important parameters body Optional parameter Perform all async operations here like API calls fetching from data base returns a List<Mutation(store,type)> mutations Required paramter Takes 2 paramter result the returned value of body() and payload for dependcy injection","title":"Defining Actions"},{"location":"quickstart/#creating-our-widget","text":"class CounterApp extends StatefulWidget { CounterApp ({ Key key }) : super ( key: key ); @override _CounterAppState createState () => _CounterAppState (); } class _CounterAppState extends State < CounterApp > { final _counter = CounterState (); void handleIncrement () => incrementRef ( _counter ). run (); void handleDecrement () => decrementRef ( _counter ). run (); void handleError () => errorRef ( _counter ). run (); void handleCount () => setRef ( CounterParam ( _counter , 5 )). run (); @override Widget build ( BuildContext context ) { return Scaffold ( appBar: AppBar ( title: Text ( \"Counter\" )), body: StateBuilder < int > ( initialState: _counter . state , stream: _counter . stream , rebuildOnly: ( state ) => (( state . data ?? 1 ) % 2 == 0 ), builder: ( context , state , init ) => Center ( child: Text ( state . toString ())), ), floatingActionButton: Column ( mainAxisAlignment: MainAxisAlignment . end , children: < Widget > [ FloatingActionButton ( mini: true , heroTag: null , onPressed: handleIncrement , child: Icon ( Icons . add ), ), FloatingActionButton ( mini: true , heroTag: null , onPressed: handleDecrement , child: Icon ( Icons . remove ), ), FloatingActionButton ( mini: true , heroTag: null , onPressed: handleError , child: Icon ( Icons . close ), ), FloatingActionButton ( mini: true , heroTag: null , onPressed: handleCount , child: Icon ( Icons . plus_one ), ), ], ), ); } } The StateBuilder widget takes the Store and listens for event. It might look very raw as because the depency inject is very loosely coupled so anyone can use their favourite depency injection library.","title":"Creating our widget"},{"location":"quickstart/#creating-views","text":"Views are the integrating point this is where we build our widget tree and integrate everything. Create a file name views.dart and paste the following code. class App extends StatelessWidget { const App ({ Key key }) : super ( key: key ); @override Widget build ( BuildContext context ) { return MaterialApp ( home: CounterApp ()); } }","title":"Creating views"},{"location":"Concepts/actions/","text":"Actions \u00b6 Overview \u00b6 Actions are functions, their job is to perform a task. The key difference between a normal function and an Action is that once an action is completed it returns a list of mutations. Then these mutations are sent to their respective stores which may or may not cause change in the state. Action do the How part of obtaining the data, it can be from a database, an api call, a file or anything. Once the data is obtained they are converted to mutations. Therefore, in general we call Action causes changes but it's important to understand that Actions play a bigger role than just mutating state. ActionRef \u00b6 ActionRef or ActionReference is where you define your actions but do not create it. It's only a refernce to your action. final setRef = ActionRef < CounterParam , void > ( body: ( payload ) async { await Future . delayed ( Duration ( milliseconds: payload . seconds )); }, mutations: ( result , payload ) => [ Mutation ( payload . store , CountMutation ( payload . count ))], ); setRef above is refernce we can obtain it anywhere. Generally it's better to define all your action refernce in a class as static values. Whenever we want to create an Action we will call the action reference //CounterParam is the required payload here final action = setRef ( CounterParam ()); But the actions still hasn't been executed, the Dispatcher knows that we have created an action but we haven't requested the dispatcher to execute it. If we want to execute our action we will call the run() action . run ()","title":"Actions"},{"location":"Concepts/actions/#actions","text":"","title":"Actions"},{"location":"Concepts/actions/#overview","text":"Actions are functions, their job is to perform a task. The key difference between a normal function and an Action is that once an action is completed it returns a list of mutations. Then these mutations are sent to their respective stores which may or may not cause change in the state. Action do the How part of obtaining the data, it can be from a database, an api call, a file or anything. Once the data is obtained they are converted to mutations. Therefore, in general we call Action causes changes but it's important to understand that Actions play a bigger role than just mutating state.","title":"Overview"},{"location":"Concepts/actions/#actionref","text":"ActionRef or ActionReference is where you define your actions but do not create it. It's only a refernce to your action. final setRef = ActionRef < CounterParam , void > ( body: ( payload ) async { await Future . delayed ( Duration ( milliseconds: payload . seconds )); }, mutations: ( result , payload ) => [ Mutation ( payload . store , CountMutation ( payload . count ))], ); setRef above is refernce we can obtain it anywhere. Generally it's better to define all your action refernce in a class as static values. Whenever we want to create an Action we will call the action reference //CounterParam is the required payload here final action = setRef ( CounterParam ()); But the actions still hasn't been executed, the Dispatcher knows that we have created an action but we haven't requested the dispatcher to execute it. If we want to execute our action we will call the run() action . run ()","title":"ActionRef"},{"location":"Concepts/dispatcher/","text":"Dispatcher \u00b6 Overview \u00b6 Dispatcher is a control unit of your application. It provides a mechanism to execute actions and dispatch mutations to the stores. Throughout the application you have a single Dispatcher, it becomes very useful in managing dependencies among actions. For example waiting for a set of actions to complete before executing an action. Dispatcher also provides onError and onDone callbacks on every action. For Flux/Redux developers In Nano the Dispatcher doesn't keep the track of stores, you will have to provide them with your actions whereas in Redux/Flux every store registers itself with the dispatcher, which allows your to acess the Store directly from the disptacher.","title":"Dispatcher"},{"location":"Concepts/dispatcher/#dispatcher","text":"","title":"Dispatcher"},{"location":"Concepts/dispatcher/#overview","text":"Dispatcher is a control unit of your application. It provides a mechanism to execute actions and dispatch mutations to the stores. Throughout the application you have a single Dispatcher, it becomes very useful in managing dependencies among actions. For example waiting for a set of actions to complete before executing an action. Dispatcher also provides onError and onDone callbacks on every action. For Flux/Redux developers In Nano the Dispatcher doesn't keep the track of stores, you will have to provide them with your actions whereas in Redux/Flux every store registers itself with the dispatcher, which allows your to acess the Store directly from the disptacher.","title":"Overview"},{"location":"Concepts/store/","text":"Store \u00b6 Overview \u00b6 Stores are somewhat similar to Redux Store or Bloc. They contain the state of the application and the logic to mutate the state. A store can hold any type of value, a single record or a collection. The major difference in Nano is that the application state is divided into multiple stores depending upon features or domain, this allows us to make our code modular. Stores also only contain the business logic related only to its state mutation and computated value, a store only cares about the end input it doesn't care about How the input values are obtained. Stores are essentially a part of Presentation Layer Stores are a communication link between your Data Layer and Views. A store receives the mutations and it renders a new state accordingls. It only cares about the data required not How you obtained the data. Mutation \u00b6 Mutation are events that are received by the Store and cause mutation of the state. Every store is registered with specific mutations, only those mutation event can cause change of state. Mutations are so received sequentially by the store. At a time only one mutation are processed, rest of the mutations are queued. Mutations are queued by the order they arrive to the store. Reducer \u00b6 Reducer are pure functions that contains logic of mutating the state. Unlike Redux reducer is a part of the Store, every store has it's own reducer. Once a mutation is received it's forwarded to the reducer, where you identify the mutation type and change the state accordingly","title":"Store"},{"location":"Concepts/store/#store","text":"","title":"Store"},{"location":"Concepts/store/#overview","text":"Stores are somewhat similar to Redux Store or Bloc. They contain the state of the application and the logic to mutate the state. A store can hold any type of value, a single record or a collection. The major difference in Nano is that the application state is divided into multiple stores depending upon features or domain, this allows us to make our code modular. Stores also only contain the business logic related only to its state mutation and computated value, a store only cares about the end input it doesn't care about How the input values are obtained. Stores are essentially a part of Presentation Layer Stores are a communication link between your Data Layer and Views. A store receives the mutations and it renders a new state accordingls. It only cares about the data required not How you obtained the data.","title":"Overview"},{"location":"Concepts/store/#mutation","text":"Mutation are events that are received by the Store and cause mutation of the state. Every store is registered with specific mutations, only those mutation event can cause change of state. Mutations are so received sequentially by the store. At a time only one mutation are processed, rest of the mutations are queued. Mutations are queued by the order they arrive to the store.","title":"Mutation"},{"location":"Concepts/store/#reducer","text":"Reducer are pure functions that contains logic of mutating the state. Unlike Redux reducer is a part of the Store, every store has it's own reducer. Once a mutation is received it's forwarded to the reducer, where you identify the mutation type and change the state accordingly","title":"Reducer"}]}