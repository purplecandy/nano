import 'dart:async';
import 'dispatcher.dart';
import 'state_manager.dart';
import 'package:meta/meta.dart';

typedef Future<K> ActionBody<T, K>(T payload);

/// Unique id of every action
/// This is generated by the Dispatcher
/// It can also be obtained by `Dispatcher.instance.getId()`
class ActionId {
  final String token;
  ActionId(this.token);

  @override
  String toString() => "Action - $token";
}

class Mutation<T> {
  final Store store;
  final T type;
  Mutation(this.store, this.type);

  Type get typeOf => type.runtimeType;
}

typedef List<Mutation> ActionMutations<T, K>(K response, T payload);
typedef dynamic ActionMutation<K, T>(K response, T payload);
typedef List<Store> ProxyStores<T>(T payload);

class Action {
  final Stream<Mutation> Function() body;
  final List<Mutation> Function(Object error) onError;
  final void Function() onDone;
  final ActionId _id = Dispatcher.instance.getId();
  final List<ActionId> waitFor;
  ActionId get id => _id;
  Action(this.body, {this.onDone, this.onError, this.waitFor});
  void clear(ActionId id) {
    assert(id != null);
    waitFor.clear();
  }

  Future<void> run() async => await Dispatcher.instance.add(this);
}

/// ActionRef will return a copy of Action which can be passed to the dispatcher to mutate changes
class ActionRef<T, K> implements Function {
  final ActionBody<T, K> body;
  final ActionMutations<T, K> mutations;
  final bool hasProxyMutation;
  final Store Function(T payload) store;
  final ActionMutation<K, T> mutation;
  ActionRef({
    this.mutations,
    this.mutation,
    this.body,
    this.hasProxyMutation = false,
    this.store,
  });

  Action call(
      {T payload,
      List<ActionId> waitFor,
      List<Mutation> Function(Object error) onError,
      void Function() onDone}) {
    assert(mutations != null || (store != null && mutation != null));
    return Action(
      () async* {
        final result = await Future.microtask(() => body(payload));
        if (mutations != null) {
          final listOfMutations = mutations(result, payload);
          for (var mutation in listOfMutations) {
            yield mutation;
          }
        } else {
          final storeObject = store(payload);
          final mutationObject = mutation(result, payload);
          yield Mutation(storeObject, mutationObject);
        }
      },
      waitFor: waitFor,
      onDone: onDone,
      onError: onError,
    );
  }
}
