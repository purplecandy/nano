import 'dart:async';
import 'package:meta/meta.dart';
import 'package:nano/nano.dart';

typedef Future<K> ActionBody<T, K>(T payload);
typedef dynamic ActionMutation<K, T>(K response, T payload);
typedef List<Store> ProxyStores<T>(T payload);

/// Unique id of every action
/// This is generated by the Dispatcher
/// It can also be obtained by `Dispatcher.instance.getId()`
class ActionId {
  final String token;
  ActionId(this.token);

  @override
  String toString() => "Action - $token";
}

/// Actions that are send to the Dispatcher and executed
/// which causes mutation to the specified store's state
class Action<T, K> implements Function {
  /// Asynchronous middlebefore that's executed before running the mutation.
  ///
  /// This is where you're supposed to perform the *How* part of obtaining the required data for the mutation
  /// Example: api calls, database calls
  final ActionBody<T, K> body;

  /// A unique id that represents a specific instance of an action
  final ActionId id;

  /// A list actions that you want to wait for them to be executed successfully before executing this action.
  /// If anyone of the action fails in then the action will not execute
  ///
  /// This can be used to achive consistency between shared stores, as this will ensure when it only execute if the depdencies have executed successfuly.
  final List<ActionId> waitFor;

  /// This is an optional parameter that you can use to send data from Views to your Action.
  ///
  /// In otherwords, in some cases your actions might need the user inputs or some values for example credentials and inside the Action you take those credentials and process it.
  /// That usercredentiials can be passed from payload.
  final T payload;

  /// The type mutation this action will send to the specified `store`
  ///
  /// First argument is the result from the `body` if you're not returning anything it will be `null`.
  ///
  /// Second argument is the `payload`.
  final ActionMutation<K, T> mutation;

  /// A callback that will be called when the Action fails
  ///
  /// If you return a value except `null` it will be used to update the state as error directly as fallback state. If you prevent that return `null` in the end
  final Object Function(Object error) onError;

  /// A callback that will be called when the Action executes successfully.
  final void Function() onDone;

  /// The `Store` it this action will act on or send mutations to. In `nano` actions are descriptive, it has to explicitly specify what it is going to do.
  final Store store;
  Action({
    @required this.id,
    this.body,
    this.payload,
    @required this.mutation,
    @required this.store,
    this.waitFor,
    this.onError,
    this.onDone,
  })  : assert(id != null),
        assert(mutation != null),
        assert(store != null);

  Future call() async {
    K result;
    if (body != null) result = await Future.microtask(() => body(payload));
    final mut = mutation(result, payload);
    return mut;
  }

  Future<void> run() async => await Dispatcher.instance.add(this);

  void clear(ActionId id) {
    assert(id != null);
    waitFor.clear();
  }

  ///Creates an `Action` without any reference for quickly dispatching certain mutation that doesn't require any `body` parameter
  factory Action.anonymous(
    Store store,
    dynamic mutation, {
    Object Function(Object error) onError,
    void Function() onDone,
    List<ActionId> waitFor,
  }) {
    return Action(
      id: Dispatcher.instance.getId(),
      mutation: (r, p) => mutation,
      store: store,
      onDone: onDone,
      onError: onError,
      waitFor: waitFor,
      body: null,
      payload: null,
    );
  }
}

/// ActionRef or ActionReference that is used to create an action when required.
///
/// `T` defined the type of `payload`
///
/// `K` defined the return type of `body(payload)`
class ActionRef<T, K> implements Function {
  /// Asynchronous middlebefore that's executed before running the mutation.
  ///
  /// This is where you're supposed to perform the *How* part of obtaining the required data for the mutation
  /// Example: api calls, database calls
  final ActionBody<T, K> body;

  /// The type mutation this action will send to the specified `store`
  ///
  /// First argument is the result from the `body` if you're not returning anything it will be `null`.
  ///
  /// Second argument is the `payload`.
  final ActionMutation<K, T> mutation;

  /// The `Store` it this action will act on or send mutations to. In `nano` actions are descriptive, it has to explicitly specify what it is going to do.
  final Store Function(T payload) store;

  ActionRef({
    @required this.mutation,
    @required this.store,
    this.body,
  })  : assert(mutation != null),
        assert(store != null);

  Action<T, K> call({
    /// This is an optional parameter that you can use to send data from Views to your Action.
    ///
    /// In otherwords, in some cases your actions might need the user inputs or some values for example credentials and inside the Action you take those credentials and process it.
    /// That usercredentiials can be passed from payload.
    T payload,

    /// A list actions that you want to wait for them to be executed successfully before executing this action.
    /// If anyone of the action fails in then the action will not execute
    ///
    /// This can be used to achive consistency between shared stores, as this will ensure when it only execute if the depdencies have executed successfuly.
    List<ActionId> waitFor,

    /// A callback that will be called when the Action fails
    ///
    /// If you return a value except `null` it will be used to update the state as error directly as fallback state. If you prevent that return `null` in the end
    Object Function(Object error) onError,

    /// A callback that will be called when the Action executes successfully.
    void Function() onDone,
  }) {
    return Action<T, K>(
      id: Dispatcher.instance.getId(),
      body: body,
      store: store(payload),
      mutation: mutation,
      payload: payload,
      waitFor: waitFor,
      onDone: onDone,
      onError: onError,
    );
  }
}
